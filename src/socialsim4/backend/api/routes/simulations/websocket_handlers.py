"""
Simulation WebSocket event handlers.

Manages real-time bidirectional communication for simulation events.
Includes tree-level and node-level event subscriptions.

Clients can subscribe to receive events such as:
- attached: When a new node is attached to the tree
- run_start: When a node starts executing
- run_finish: When a node finishes execution
- deleted: When a subtree is deleted
- node_events: Node-specific events

Contains:
    - simulation_tree_events_ws: Tree-level WebSocket connection
    - simulation_tree_node_events_ws: Node-level WebSocket connection
"""

import asyncio
import logging

from litestar import websocket
from litestar.connection import WebSocket
from litestar.exceptions import WebSocketDisconnect

from socialsim4.backend.core.database import get_session

from .helpers import (
    get_simulation_for_owner,
    get_tree_record,
    resolve_user_from_token,
)


logger = logging.getLogger(__name__)


@websocket("/{simulation_id:str}/tree/events")
async def simulation_tree_events_ws(
    socket: WebSocket,
    simulation_id: str,
) -> None:
    """
    Subscribe to tree-level simulation events.

    Provides real-time updates for all events affecting the
    simulation tree including node attachments, execution
    start/finish, and deletions.

    Authentication:
        Requires valid JWT token via query parameter or cookie.

    Args:
        socket: WebSocket connection
        simulation_id: Simulation identifier

    Events sent:
        - attached: New node attached to tree
        - run_start: Node execution started
        - run_finish: Node execution finished
        - deleted: Subtree deleted
    """
    token = socket.query_params.get("token")

    async with get_session() as session:
        user = await resolve_user_from_token(token or "", session)
        if user is None:
            await socket.close(code=1008)
            return

        sim = await get_simulation_for_owner(session, user.id, simulation_id)
        record = await get_tree_record(sim, session, user.id)

    await socket.accept()
    queue: asyncio.Queue = asyncio.Queue()
    record.subs.append(queue)

    logger.debug("WS tree events subscribed: sim=%s", simulation_id)

    try:
        while True:
            event = await queue.get()
            try:
                await socket.send_json(event)
            except WebSocketDisconnect as e:
                logger.info(
                    "WebSocket disconnected (tree events) for sim %s: %s",
                    simulation_id,
                    e,
                )
                break
            except Exception:
                logger.exception("WS send_json failed for sim %s (tree events)", simulation_id)
                break
    finally:
        if queue in record.subs:
            record.subs.remove(queue)
        logger.debug("WS tree events unsubscribed: sim=%s", simulation_id)


@websocket("/{simulation_id:str}/tree/{node_id:int}/events")
async def simulation_tree_node_events_ws(
    socket: WebSocket,
    simulation_id: str,
    node_id: int,
) -> None:
    """
    Subscribe to node-specific simulation events.

    Provides real-time updates for events specific to a single
    node in the simulation tree. This includes agent actions,
    environment updates, and other node-level events.

    Authentication:
        Requires valid JWT token via query parameter, Authorization header,
        or cookie (in that order for dev-friendly fallback).

    Args:
        socket: WebSocket connection
        simulation_id: Simulation identifier
        node_id: Tree node ID to subscribe to

    Events sent:
        - All events generated by the specific node's simulator
    """
    # Try to get token from query param, Authorization header, or cookie
    token = socket.query_params.get("token")

    if not token:
        auth_header = None
        try:
            auth_header = socket.headers.get("authorization") or socket.headers.get("Authorization")
        except Exception:
            auth_header = None

        if auth_header and isinstance(auth_header, str) and auth_header.lower().startswith("bearer "):
            token = auth_header.split(" ", 1)[1].strip()

    if not token:
        try:
            token = socket.cookies.get("socialsim4.access")
        except Exception:
            token = None

    async with get_session() as session:
        user = await resolve_user_from_token(token or "", session)
        if user is None:
            await socket.close(code=1008)
            return

        sim = await get_simulation_for_owner(session, user.id, simulation_id)
        record = await get_tree_record(sim, session, user.id)

        if int(node_id) not in record.tree.nodes:
            await socket.close(code=1008)
            return

    await socket.accept()
    queue: asyncio.Queue = asyncio.Queue()
    record.tree.add_node_sub(int(node_id), queue)

    logger.debug("WS node events subscribed: sim=%s node=%s", simulation_id, node_id)

    try:
        while True:
            event = await queue.get()
            try:
                await socket.send_json(event)
            except WebSocketDisconnect as e:
                logger.info(
                    "WebSocket disconnected (node events) for sim %s node %s: %s",
                    simulation_id,
                    node_id,
                    e,
                )
                break
            except Exception:
                logger.exception(
                    "WS send_json failed for sim %s node %s (node events)",
                    simulation_id,
                    node_id,
                )
                break
    finally:
        record.tree.remove_node_sub(int(node_id), queue)
        logger.debug("WS node events unsubscribed: sim=%s node=%s", simulation_id, node_id)
